{
  "address": "0x65E2b520AE62E40696a3869f01a570C32f6e8174",
  "abi": [],
  "transactionHash": "0x57bc8ddcb4cd828538d6063cc571fd0a76573ad2c805a544ffaf87af4154199d",
  "receipt": {
    "to": null,
    "from": "0x7aF08613Bd9E2111EbA13a2d5d08a9A0cF4d3307",
    "contractAddress": "0x65E2b520AE62E40696a3869f01a570C32f6e8174",
    "transactionIndex": 1,
    "gasUsed": "72227",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6b8f3a620f790ae9833f5e692dcbc2e7dae22a8879c178852b704dd147c3c24e",
    "transactionHash": "0x57bc8ddcb4cd828538d6063cc571fd0a76573ad2c805a544ffaf87af4154199d",
    "logs": [],
    "blockNumber": 2771639,
    "cumulativeGasUsed": "124445",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "064a3948b0a7f15e784edb20aa805bc2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"author\":\"Aave\",\"kind\":\"dev\",\"methods\":{},\"title\":\"CalldataLogic library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"@aave/core-v3/contracts/protocol/libraries/logic/CalldataLogic.sol\":\"CalldataLogic\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[]},\"sources\":{\"@aave/core-v3/contracts/protocol/libraries/logic/CalldataLogic.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title CalldataLogic library\\n * @author Aave\\n * @notice Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction\\n */\\nlibrary CalldataLogic {\\n  /**\\n   * @notice Decodes compressed supply params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed supply params\\n   * @return The address of the underlying reserve\\n   * @return The amount to supply\\n   * @return The referralCode\\n   */\\n  function decodeSupplyParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, uint256, uint16) {\\n    uint16 assetId;\\n    uint256 amount;\\n    uint16 referralCode;\\n\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      referralCode := and(shr(144, args), 0xFFFF)\\n    }\\n    return (reservesList[assetId], amount, referralCode);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed supply params to standard params along with permit params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed supply with permit params\\n   * @return The address of the underlying reserve\\n   * @return The amount to supply\\n   * @return The referralCode\\n   * @return The deadline of the permit\\n   * @return The V value of the permit signature\\n   */\\n  function decodeSupplyWithPermitParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, uint256, uint16, uint256, uint8) {\\n    uint256 deadline;\\n    uint8 permitV;\\n\\n    assembly {\\n      deadline := and(shr(160, args), 0xFFFFFFFF)\\n      permitV := and(shr(192, args), 0xFF)\\n    }\\n    (address asset, uint256 amount, uint16 referralCode) = decodeSupplyParams(reservesList, args);\\n\\n    return (asset, amount, referralCode, deadline, permitV);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed withdraw params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed withdraw params\\n   * @return The address of the underlying reserve\\n   * @return The amount to withdraw\\n   */\\n  function decodeWithdrawParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, uint256) {\\n    uint16 assetId;\\n    uint256 amount;\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n    }\\n    if (amount == type(uint128).max) {\\n      amount = type(uint256).max;\\n    }\\n    return (reservesList[assetId], amount);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed borrow params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed borrow params\\n   * @return The address of the underlying reserve\\n   * @return The amount to borrow\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\n   * @return The referralCode\\n   */\\n  function decodeBorrowParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, uint256, uint256, uint16) {\\n    uint16 assetId;\\n    uint256 amount;\\n    uint256 interestRateMode;\\n    uint16 referralCode;\\n\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      interestRateMode := and(shr(144, args), 0xFF)\\n      referralCode := and(shr(152, args), 0xFFFF)\\n    }\\n\\n    return (reservesList[assetId], amount, interestRateMode, referralCode);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed repay params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed repay params\\n   * @return The address of the underlying reserve\\n   * @return The amount to repay\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\n   */\\n  function decodeRepayParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, uint256, uint256) {\\n    uint16 assetId;\\n    uint256 amount;\\n    uint256 interestRateMode;\\n\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      interestRateMode := and(shr(144, args), 0xFF)\\n    }\\n\\n    if (amount == type(uint128).max) {\\n      amount = type(uint256).max;\\n    }\\n\\n    return (reservesList[assetId], amount, interestRateMode);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed repay params to standard params along with permit params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed repay with permit params\\n   * @return The address of the underlying reserve\\n   * @return The amount to repay\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\n   * @return The deadline of the permit\\n   * @return The V value of the permit signature\\n   */\\n  function decodeRepayWithPermitParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, uint256, uint256, uint256, uint8) {\\n    uint256 deadline;\\n    uint8 permitV;\\n\\n    (address asset, uint256 amount, uint256 interestRateMode) = decodeRepayParams(\\n      reservesList,\\n      args\\n    );\\n\\n    assembly {\\n      deadline := and(shr(152, args), 0xFFFFFFFF)\\n      permitV := and(shr(184, args), 0xFF)\\n    }\\n\\n    return (asset, amount, interestRateMode, deadline, permitV);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed swap borrow rate mode params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed swap borrow rate mode params\\n   * @return The address of the underlying reserve\\n   * @return The interest rate mode, 1 for stable 2 for variable debt\\n   */\\n  function decodeSwapBorrowRateModeParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, uint256) {\\n    uint16 assetId;\\n    uint256 interestRateMode;\\n\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      interestRateMode := and(shr(16, args), 0xFF)\\n    }\\n\\n    return (reservesList[assetId], interestRateMode);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed rebalance stable borrow rate params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed rabalance stable borrow rate params\\n   * @return The address of the underlying reserve\\n   * @return The address of the user to rebalance\\n   */\\n  function decodeRebalanceStableBorrowRateParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, address) {\\n    uint16 assetId;\\n    address user;\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      user := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n    }\\n    return (reservesList[assetId], user);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed set user use reserve as collateral params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args The packed set user use reserve as collateral params\\n   * @return The address of the underlying reserve\\n   * @return True if to set using as collateral, false otherwise\\n   */\\n  function decodeSetUserUseReserveAsCollateralParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args\\n  ) internal view returns (address, bool) {\\n    uint16 assetId;\\n    bool useAsCollateral;\\n    assembly {\\n      assetId := and(args, 0xFFFF)\\n      useAsCollateral := and(shr(16, args), 0x1)\\n    }\\n    return (reservesList[assetId], useAsCollateral);\\n  }\\n\\n  /**\\n   * @notice Decodes compressed liquidation call params to standard params\\n   * @param reservesList The addresses of all the active reserves\\n   * @param args1 The first half of packed liquidation call params\\n   * @param args2 The second half of the packed liquidation call params\\n   * @return The address of the underlying collateral asset\\n   * @return The address of the underlying debt asset\\n   * @return The address of the user to liquidate\\n   * @return The amount of debt to cover\\n   * @return True if receiving aTokens, false otherwise\\n   */\\n  function decodeLiquidationCallParams(\\n    mapping(uint256 => address) storage reservesList,\\n    bytes32 args1,\\n    bytes32 args2\\n  ) internal view returns (address, address, address, uint256, bool) {\\n    uint16 collateralAssetId;\\n    uint16 debtAssetId;\\n    address user;\\n    uint256 debtToCover;\\n    bool receiveAToken;\\n\\n    assembly {\\n      collateralAssetId := and(args1, 0xFFFF)\\n      debtAssetId := and(shr(16, args1), 0xFFFF)\\n      user := and(shr(32, args1), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n\\n      debtToCover := and(args2, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      receiveAToken := and(shr(128, args2), 0x1)\\n    }\\n\\n    if (debtToCover == type(uint128).max) {\\n      debtToCover = type(uint256).max;\\n    }\\n\\n    return (\\n      reservesList[collateralAssetId],\\n      reservesList[debtAssetId],\\n      user,\\n      debtToCover,\\n      receiveAToken\\n    );\\n  }\\n}\\n\",\"keccak256\":\"0x9c12dfdab51ccb9f9c00489d0a06e67e2adcbcb7eef98e4585af62060f2d60b5\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200f4384053b8732e94b60e1db52575f84180d89f625837b6a3254578a47780d4c64736f6c634300080a0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212200f4384053b8732e94b60e1db52575f84180d89f625837b6a3254578a47780d4c64736f6c634300080a0033",
  "devdoc": {
    "author": "Aave",
    "kind": "dev",
    "methods": {},
    "title": "CalldataLogic library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}